#!/usr/bin/env ruby
# 
# qc_reminder
# 
# Created by Gordon Fontenot for WheelsTV
# 
# Scans a set of folders used for Quality Control,
# and if it finds videos, emails the employee responsible
# for that stage of the QC process to let them know they
# have videos ready to QC.


require 'rubygems'
require 'pony'
require 'tinder'

@email_array = {"Gordon" => "gfontenot@wheelstv.net",
                "Nick" => "nbrecken@wheelstv.net",
                "Leo" => "lbonarrigo@wheelstv.net",
                "Kipp" => "kreynolds@wheelstv.net",
                "George" => "gkennedy@wheelstv.net",
                "Ryan" => "rnichols@wheelstv.net",
                "Collin" => "cdavis@wheelstv.net",
                "Jim" => "jimbar@wheelstv.net",
                "Jeff" => "jeffbarisano@wheelstv.net",
                "Rich" => "rtaber@wheelstv.net"}

Pony.options = { :from => "production@wheelstv.net", :via => :smtp, :via_options => {
  :address => "smtp.1and1.com",
  :port => "25", 
  :user_name => "production@wheelstv.net", 
  :password => "wheelstv123", 
  :authentication => :plain,
  :domain => "localhost.localdomain", 
  } }

def notify_user(person, product, count, box, type)
  if user_on_campfire? person
    msg_user(person, product, count, box, type)
  else
    email_user(person, product, count, box, type)
  end
end

def email_user(person, product, count, box, type)
  msg = "Hi #{person},\n\nThis is a friendly notification to let you know that you currently have #{count} #{product} #{type}s ready for QC in your #{box} box.\n\nThanks,\nThe Management"
  subject = "You have #{count} #{product} #{type}s ready for QC"

  Pony.mail(:to => @email_array[person], :subject => subject, :body => msg)
  
  time_stamp = Time.now.strftime("%D - %r")
  
  puts "#{time_stamp} - Email sent to #{person} (#{count} #{product} #{type}s in #{box})"
end

def user_on_campfire? user_name
  campfire = Tinder::Campfire.new 'wheelstv', :token => 'b00ffa07d0e3e9ad47ba809ccad4ee34b51e2e44'
  room = campfire.find_room_by_name "The Office"
  room.users.each do |user|
    if user.name == user_name
      return true
    end
  end
  
  return false
end

def msg_user (person, product, count, box, type)
  campfire = Tinder::Campfire.new 'wheelstv', :token => 'b00ffa07d0e3e9ad47ba809ccad4ee34b51e2e44'
  room = campfire.find_room_by_name "The Office"
  room.speak "#{person}: You have #{count} #{product} #{type}s ready for QC (#{box})"

  time_stamp = Time.now.strftime("%D - %r")

  puts "#{time_stamp} - #{person} Notified via Campfire (#{count} #{product} #{type}s in #{box})"

end


def notify_video_qc

  base_dir =  "/Volumes/Exported items/"
  
  product_array = { "1onONE" => "Ryan",
                    "Top200" => "Kipp",
                    "POV" => "Leo",
                    "AutoTrader" => "Nick"}
  
  qc_array = {"1_Technical_" => "George",
              "2_Creative_" => "Jim",
              "4_Final Review_" => "Gordon"}
  
  product_array.each_pair do |product, editor|
  
    qc_dir = File.join(base_dir, product, "/Latest Batch/QC/")
    begin
      for box in ["0_Editor Review_", "3_Editor Fixes_"] do box
        count = Dir.entries("#{qc_dir}#{box}#{editor}").delete_if {|file| /^\./.match(file)}.size
        unless count == 0
      
        notify_user(editor, product, count, box.split("_")[1], "video")
        end      
      end
  
      qc_array.each_pair do |box, person|
        count = Dir.entries("#{qc_dir}#{box}#{person}").delete_if {|file| /^\./.match(file)}.size
        unless count == 0
          # puts "#{person} has #{count} #{product} videos to QC"
          
            notify_user(person, product, count, box.split("_")[1], "video")
          
        end
      end
    rescue Exception => e
      puts e
    end
  end
end

def notify_script_qc
  base_dir =  '/Users/Gordon/Dropbox/wtv dropbox/products/'
  
  top200_qc = { "1. Technical QC"         => "Jeff",
                "2. Artistic QC"          => "Jeff",
                "3. Final Review"         => "George",
                "4. Ready for Production" => "Gordon"}
  
  oneonone_qc = { "1. Technical QC"         => "Jeff",
                  "2. Artistic QC"          => "Jeff",
                  "3. Final Review"         => "Rich",
                  "4. Ready for Production" => "Gordon"}
  
  pov_qc = {    "1. Technical QC"         => "George",
                "2. Artistic QC"          => "Jim",
                "3. Final Review"         => "Jeff",
                "4. Ready for Production" => "Gordon"}
  
  product_hash = { "1onONE" => oneonone_qc,
                    "Top200" => top200_qc,
                    "POV" => pov_qc}
  
  product_hash.each_pair do |product, qc_hash|
  
    qc_dir = File.join(base_dir, product, "#{product} Scripts")
    begin
      qc_hash.each_pair do |box, person|
        scripts = Dir.entries("#{qc_dir}/#{box}").delete_if {|file| /^\./.match(file)}
        unless scripts.size == 0
          
#           if product == "Top200" && box == "3. Final Review"
#             new_top200_count = 0
#             co_top200_count = 0
#             for script in scripts
#               if /new/i.match script.split("_")[1]
#                 new_top200_count += 1;
#               else
#                 co_top200_count += 1
#               end
#             end
#             
#             {"Rich" => co_top200_count, "George" => new_top200_count}.each_pair do |person, count|
#             
#               if count > 0
#                 notify_user(person, product, count, box.split(". ")[1], "script")
#               end
#             end
#             
#           else
          
            notify_user(person, product, scripts.size, box.split(". ")[1], "script")
  
#           end
          
        end
      end
    rescue Exception => e
      puts e
    end
  end
end

notify_video_qc
notify_script_qc